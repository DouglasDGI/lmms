sample_morerealindex[i][l] = fmod( ( sample_realindex[i][l] + ( fmod( phase[i], 100.f ) * sampLen[i] * 0.01f ) ), sampLen[i] );

unisonVoicesMinusOne = unisonVoices[i] - 1;

noteFreq = detuneWithCents( nph->frequency(), detuneVal[i] );

sample_step[i][l] = sampLen[i] * (  noteFreq / sample_rate );

sample_length_modify[i][l] = 0;

resultsample[i][l] = 0;

temp1 = 524288.f / sampLen[i];
loopStart = qMax( 0.f, morphVal[i] - rangeVal[i] ) + 1;
loopEnd = qMin( morphVal[i] + rangeVal[i], temp1 ) + 1;
currentRangeValInvert = 1.f / rangeVal[i];
currentSampLen = sampLen[i];
currentIndex = sample_morerealindex[i][l];

resultsample[i][l] += waveforms[i][currentIndex + j * currentSampLen] * ( 1 - ( abs( morphVal[i] - j ) * currentRangeValInvert ));

resultsample[i][l] /= rangeVal[i];

sample_realindex[i][l] += sample_step[i][l];

// check overflow
temp1 = sampLen[i] + sample_length_modify[i][l];
if( unlikely( sample_realindex[i][l] >= temp1 ) )
{
	sample_realindex[i][l] -= temp1;
}

sample[i][l] = resultsample[i][l] * vol[i] * 0.01f;



Abs:             .
Add:             .......
Sub:             .....
Mult:            .........

Div:             .....
Fmod:            ..
qMax:            .
qMin:            .
Pow:             .
